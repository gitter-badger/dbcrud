package org.dbcrud

import scala.util.Try

/**
 * Created by rinconj on 15/12/14.
 */

case class DbTable(name:Symbol, columns:Seq[DbColumn[_]], primaryKey:Seq[Symbol]){
  private val columnsByName = columns.map(c=>c.name->c).toMap[Symbol, DbColumn[_]]
  def column(name:Symbol) = columnsByName(name)
  def coerce[T](name:Symbol, value:String):Option[Try[T]] = columnsByName.get(name).map(c=>Try(c.dbType.asInstanceOf[SqlType[T]].fromString(value)))
}

case class DbColumn[T](name: Symbol, dbType: SqlType[T], size:Int, decimalDigits:Int=0, nullable:Boolean=true, autoIncremented:Boolean=false, autoGenerated:Boolean=false)

trait Row extends Traversable[(Symbol, Any)] {
  def apply[T](column: Symbol): T

  def apply[T](column: String): T
}

class QueryData(columns: Seq[Symbol], rows: Iterable[Array[Any]]) extends Iterable[Row] {

  def asMaps = rows.map(r => columns.map(_.name).zip(r).toMap)

  private lazy val columnToIndex = columns.map(_.name.toUpperCase).zipWithIndex.toMap

  override def iterator: Iterator[Row] = rows.iterator.map(values => new RowImpl(values))

  class RowImpl(values: Array[Any]) extends Row {

    override def foreach[U](f: ((Symbol, Any)) => U): Unit = columns.zip(values).foreach(f)

    def apply[T](column: Symbol): T = values(columnToIndex(column.name.toUpperCase)).asInstanceOf[T]

    def apply[T](column: String): T = values(columnToIndex(column.toUpperCase)).asInstanceOf[T]
  }

}

trait DataCrud {

  def createTable(name: Symbol, columns: (Symbol, Int)*)

  def tableNames: Iterable[Symbol]

  def tableDef(table:Symbol):DbTable

  def insert(table: Symbol, values: (Symbol, Any)*): Int

  def updateAll(table: Symbol, values: (Symbol, Any)*): Int

  def updateWhere(table: Symbol, where: Predicate, values: (Symbol, Any)*): Int

  def delete(table: Symbol, id: Any): Int

  def select(table: Symbol, where: Predicate=EmptyPredicate, offset: Int=0, count: Int=10, orderBy: Seq[ColumnOrder]=Nil): QueryData

  def selectById(table: Symbol, id:Any):Map[Symbol, Any]
}

object ColumnOps {

  implicit class PredicateColumn(val column: Symbol) extends AnyVal {
    def is(other: Any) = new BinaryExpression(column, other, "=")

    def lte(other: Any) = new BinaryExpression(column, other, "<=")

    def lt(other: Any) = new BinaryExpression(column, other, "<")

    def gte(other: Any) = new BinaryExpression(column, other, ">=")

    def gt(other: Any) = new BinaryExpression(column, other, ">")
  }

  implicit class RichCondition(val condition: Predicate) extends AnyVal {
    def and(other: Predicate) = new CompositePredicate(condition, other, "and")

    def or(other: Predicate) = new CompositePredicate(condition, other, "or")
  }

  implicit def simpleConditions(conditions: Seq[(Symbol, Any)]): SimpleConditions = SimpleConditions(conditions)

}

sealed trait ColumnOrder {
  def toSql: String

  override def toString = toSql
}

case class Asc(column: Symbol) extends ColumnOrder {
  override def toSql: String = column.name
}

case class Desc(column: Symbol) extends ColumnOrder {
  override def toSql: String = column.name + " DESC"
}

trait Predicate {
  def asSql: String

  def constants: Seq[Any]

  def whereSql = "WHERE " + asSql
}

object EmptyPredicate extends Predicate {
  override def asSql: String = ""

  override def constants: Seq[Any] = Nil

  override def whereSql: String = ""
}

case class SimpleConditions(conditions: Seq[(Symbol, Any)]) extends Predicate {
  override def asSql: String = conditions.map {
    case (symb: Symbol, value: Symbol) => symb.name + " = " + value.name
    case (symb: Symbol, value: Any) => symb.name + " = ?"
  }.mkString(" AND ")

  override def constants: Seq[Any] = conditions.map(_._2).filterNot(_.isInstanceOf[Symbol])
}

class BinaryExpression(left: Symbol, right: Any, op: String) extends Predicate {
  override def asSql: String = right match {
    case other: Symbol => left.name + op + other.name
    case _ => left.name + op + "?"
  }

  override def constants: Seq[Any] = right match {
    case other: Symbol => Seq()
    case value => Seq(value)
  }
}

class CompositePredicate(left: Predicate, right: Predicate, op: String) extends Predicate {
  override def asSql: String = s"(${left.asSql}) $op (${right.asSql})"

  override def constants: Seq[Any] = left.constants ++ right.constants
}
